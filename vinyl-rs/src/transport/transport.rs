// This file is generated by rust-protobuf 2.8.1. Do not edit
// @generated

// https://github.com/Manishearth/rust-clippy/issues/702
#![allow(unknown_lints)]
#![allow(clippy::all)]

#![cfg_attr(rustfmt, rustfmt_skip)]

#![allow(box_pointers)]
#![allow(dead_code)]
#![allow(missing_docs)]
#![allow(non_camel_case_types)]
#![allow(non_snake_case)]
#![allow(non_upper_case_globals)]
#![allow(trivial_casts)]
#![allow(unsafe_code)]
#![allow(unused_imports)]
#![allow(unused_results)]
//! Generated file from `transport.proto`

use protobuf::Message as Message_imported_for_functions;
use protobuf::ProtobufEnum as ProtobufEnum_imported_for_functions;

/// Generated files are compatible only with the same version
/// of protobuf runtime.
const _PROTOBUF_VERSION_CHECK: () = ::protobuf::VERSION_2_8_1;

#[derive(PartialEq,Clone,Default)]
pub struct Request {
    // message fields
    pub token: ::std::string::String,
    pub insertions: ::protobuf::RepeatedField<Insert>,
    pub query: ::protobuf::SingularPtrField<Query>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a Request {
    fn default() -> &'a Request {
        <Request as ::protobuf::Message>::default_instance()
    }
}

impl Request {
    pub fn new() -> Request {
        ::std::default::Default::default()
    }

    // string token = 1;


    pub fn get_token(&self) -> &str {
        &self.token
    }
    pub fn clear_token(&mut self) {
        self.token.clear();
    }

    // Param is passed by value, moved
    pub fn set_token(&mut self, v: ::std::string::String) {
        self.token = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_token(&mut self) -> &mut ::std::string::String {
        &mut self.token
    }

    // Take field
    pub fn take_token(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.token, ::std::string::String::new())
    }

    // repeated .vinyl.Insert insertions = 6;


    pub fn get_insertions(&self) -> &[Insert] {
        &self.insertions
    }
    pub fn clear_insertions(&mut self) {
        self.insertions.clear();
    }

    // Param is passed by value, moved
    pub fn set_insertions(&mut self, v: ::protobuf::RepeatedField<Insert>) {
        self.insertions = v;
    }

    // Mutable pointer to the field.
    pub fn mut_insertions(&mut self) -> &mut ::protobuf::RepeatedField<Insert> {
        &mut self.insertions
    }

    // Take field
    pub fn take_insertions(&mut self) -> ::protobuf::RepeatedField<Insert> {
        ::std::mem::replace(&mut self.insertions, ::protobuf::RepeatedField::new())
    }

    // .vinyl.Query query = 7;


    pub fn get_query(&self) -> &Query {
        self.query.as_ref().unwrap_or_else(|| Query::default_instance())
    }
    pub fn clear_query(&mut self) {
        self.query.clear();
    }

    pub fn has_query(&self) -> bool {
        self.query.is_some()
    }

    // Param is passed by value, moved
    pub fn set_query(&mut self, v: Query) {
        self.query = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_query(&mut self) -> &mut Query {
        if self.query.is_none() {
            self.query.set_default();
        }
        self.query.as_mut().unwrap()
    }

    // Take field
    pub fn take_query(&mut self) -> Query {
        self.query.take().unwrap_or_else(|| Query::new())
    }
}

impl ::protobuf::Message for Request {
    fn is_initialized(&self) -> bool {
        for v in &self.insertions {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.query {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.token)?;
                },
                6 => {
                    ::protobuf::rt::read_repeated_message_into(wire_type, is, &mut self.insertions)?;
                },
                7 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.query)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if !self.token.is_empty() {
            my_size += ::protobuf::rt::string_size(1, &self.token);
        }
        for value in &self.insertions {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        };
        if let Some(ref v) = self.query.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if !self.token.is_empty() {
            os.write_string(1, &self.token)?;
        }
        for v in &self.insertions {
            os.write_tag(6, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        };
        if let Some(ref v) = self.query.as_ref() {
            os.write_tag(7, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> Request {
        Request::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                    "token",
                    |m: &Request| { &m.token },
                    |m: &mut Request| { &mut m.token },
                ));
                fields.push(::protobuf::reflect::accessor::make_repeated_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<Insert>>(
                    "insertions",
                    |m: &Request| { &m.insertions },
                    |m: &mut Request| { &mut m.insertions },
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<Query>>(
                    "query",
                    |m: &Request| { &m.query },
                    |m: &mut Request| { &mut m.query },
                ));
                ::protobuf::reflect::MessageDescriptor::new::<Request>(
                    "Request",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }

    fn default_instance() -> &'static Request {
        static mut instance: ::protobuf::lazy::Lazy<Request> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const Request,
        };
        unsafe {
            instance.get(Request::new)
        }
    }
}

impl ::protobuf::Clear for Request {
    fn clear(&mut self) {
        self.token.clear();
        self.insertions.clear();
        self.query.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for Request {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for Request {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct Response {
    // message fields
    pub error: ::std::string::String,
    pub records: ::protobuf::RepeatedField<::std::vec::Vec<u8>>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a Response {
    fn default() -> &'a Response {
        <Response as ::protobuf::Message>::default_instance()
    }
}

impl Response {
    pub fn new() -> Response {
        ::std::default::Default::default()
    }

    // string error = 1;


    pub fn get_error(&self) -> &str {
        &self.error
    }
    pub fn clear_error(&mut self) {
        self.error.clear();
    }

    // Param is passed by value, moved
    pub fn set_error(&mut self, v: ::std::string::String) {
        self.error = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_error(&mut self) -> &mut ::std::string::String {
        &mut self.error
    }

    // Take field
    pub fn take_error(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.error, ::std::string::String::new())
    }

    // repeated bytes records = 2;


    pub fn get_records(&self) -> &[::std::vec::Vec<u8>] {
        &self.records
    }
    pub fn clear_records(&mut self) {
        self.records.clear();
    }

    // Param is passed by value, moved
    pub fn set_records(&mut self, v: ::protobuf::RepeatedField<::std::vec::Vec<u8>>) {
        self.records = v;
    }

    // Mutable pointer to the field.
    pub fn mut_records(&mut self) -> &mut ::protobuf::RepeatedField<::std::vec::Vec<u8>> {
        &mut self.records
    }

    // Take field
    pub fn take_records(&mut self) -> ::protobuf::RepeatedField<::std::vec::Vec<u8>> {
        ::std::mem::replace(&mut self.records, ::protobuf::RepeatedField::new())
    }
}

impl ::protobuf::Message for Response {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.error)?;
                },
                2 => {
                    ::protobuf::rt::read_repeated_bytes_into(wire_type, is, &mut self.records)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if !self.error.is_empty() {
            my_size += ::protobuf::rt::string_size(1, &self.error);
        }
        for value in &self.records {
            my_size += ::protobuf::rt::bytes_size(2, &value);
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if !self.error.is_empty() {
            os.write_string(1, &self.error)?;
        }
        for v in &self.records {
            os.write_bytes(2, &v)?;
        };
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> Response {
        Response::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                    "error",
                    |m: &Response| { &m.error },
                    |m: &mut Response| { &mut m.error },
                ));
                fields.push(::protobuf::reflect::accessor::make_repeated_field_accessor::<_, ::protobuf::types::ProtobufTypeBytes>(
                    "records",
                    |m: &Response| { &m.records },
                    |m: &mut Response| { &mut m.records },
                ));
                ::protobuf::reflect::MessageDescriptor::new::<Response>(
                    "Response",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }

    fn default_instance() -> &'static Response {
        static mut instance: ::protobuf::lazy::Lazy<Response> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const Response,
        };
        unsafe {
            instance.get(Response::new)
        }
    }
}

impl ::protobuf::Clear for Response {
    fn clear(&mut self) {
        self.error.clear();
        self.records.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for Response {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for Response {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct LoginRequest {
    // message fields
    pub username: ::std::string::String,
    pub password: ::std::string::String,
    pub keyspace: ::std::string::String,
    pub file_descriptor: ::std::vec::Vec<u8>,
    pub records: ::protobuf::RepeatedField<Record>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a LoginRequest {
    fn default() -> &'a LoginRequest {
        <LoginRequest as ::protobuf::Message>::default_instance()
    }
}

impl LoginRequest {
    pub fn new() -> LoginRequest {
        ::std::default::Default::default()
    }

    // string username = 1;


    pub fn get_username(&self) -> &str {
        &self.username
    }
    pub fn clear_username(&mut self) {
        self.username.clear();
    }

    // Param is passed by value, moved
    pub fn set_username(&mut self, v: ::std::string::String) {
        self.username = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_username(&mut self) -> &mut ::std::string::String {
        &mut self.username
    }

    // Take field
    pub fn take_username(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.username, ::std::string::String::new())
    }

    // string password = 2;


    pub fn get_password(&self) -> &str {
        &self.password
    }
    pub fn clear_password(&mut self) {
        self.password.clear();
    }

    // Param is passed by value, moved
    pub fn set_password(&mut self, v: ::std::string::String) {
        self.password = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_password(&mut self) -> &mut ::std::string::String {
        &mut self.password
    }

    // Take field
    pub fn take_password(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.password, ::std::string::String::new())
    }

    // string keyspace = 3;


    pub fn get_keyspace(&self) -> &str {
        &self.keyspace
    }
    pub fn clear_keyspace(&mut self) {
        self.keyspace.clear();
    }

    // Param is passed by value, moved
    pub fn set_keyspace(&mut self, v: ::std::string::String) {
        self.keyspace = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_keyspace(&mut self) -> &mut ::std::string::String {
        &mut self.keyspace
    }

    // Take field
    pub fn take_keyspace(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.keyspace, ::std::string::String::new())
    }

    // bytes file_descriptor = 4;


    pub fn get_file_descriptor(&self) -> &[u8] {
        &self.file_descriptor
    }
    pub fn clear_file_descriptor(&mut self) {
        self.file_descriptor.clear();
    }

    // Param is passed by value, moved
    pub fn set_file_descriptor(&mut self, v: ::std::vec::Vec<u8>) {
        self.file_descriptor = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_file_descriptor(&mut self) -> &mut ::std::vec::Vec<u8> {
        &mut self.file_descriptor
    }

    // Take field
    pub fn take_file_descriptor(&mut self) -> ::std::vec::Vec<u8> {
        ::std::mem::replace(&mut self.file_descriptor, ::std::vec::Vec::new())
    }

    // repeated .vinyl.Record records = 5;


    pub fn get_records(&self) -> &[Record] {
        &self.records
    }
    pub fn clear_records(&mut self) {
        self.records.clear();
    }

    // Param is passed by value, moved
    pub fn set_records(&mut self, v: ::protobuf::RepeatedField<Record>) {
        self.records = v;
    }

    // Mutable pointer to the field.
    pub fn mut_records(&mut self) -> &mut ::protobuf::RepeatedField<Record> {
        &mut self.records
    }

    // Take field
    pub fn take_records(&mut self) -> ::protobuf::RepeatedField<Record> {
        ::std::mem::replace(&mut self.records, ::protobuf::RepeatedField::new())
    }
}

impl ::protobuf::Message for LoginRequest {
    fn is_initialized(&self) -> bool {
        for v in &self.records {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.username)?;
                },
                2 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.password)?;
                },
                3 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.keyspace)?;
                },
                4 => {
                    ::protobuf::rt::read_singular_proto3_bytes_into(wire_type, is, &mut self.file_descriptor)?;
                },
                5 => {
                    ::protobuf::rt::read_repeated_message_into(wire_type, is, &mut self.records)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if !self.username.is_empty() {
            my_size += ::protobuf::rt::string_size(1, &self.username);
        }
        if !self.password.is_empty() {
            my_size += ::protobuf::rt::string_size(2, &self.password);
        }
        if !self.keyspace.is_empty() {
            my_size += ::protobuf::rt::string_size(3, &self.keyspace);
        }
        if !self.file_descriptor.is_empty() {
            my_size += ::protobuf::rt::bytes_size(4, &self.file_descriptor);
        }
        for value in &self.records {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if !self.username.is_empty() {
            os.write_string(1, &self.username)?;
        }
        if !self.password.is_empty() {
            os.write_string(2, &self.password)?;
        }
        if !self.keyspace.is_empty() {
            os.write_string(3, &self.keyspace)?;
        }
        if !self.file_descriptor.is_empty() {
            os.write_bytes(4, &self.file_descriptor)?;
        }
        for v in &self.records {
            os.write_tag(5, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        };
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> LoginRequest {
        LoginRequest::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                    "username",
                    |m: &LoginRequest| { &m.username },
                    |m: &mut LoginRequest| { &mut m.username },
                ));
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                    "password",
                    |m: &LoginRequest| { &m.password },
                    |m: &mut LoginRequest| { &mut m.password },
                ));
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                    "keyspace",
                    |m: &LoginRequest| { &m.keyspace },
                    |m: &mut LoginRequest| { &mut m.keyspace },
                ));
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeBytes>(
                    "file_descriptor",
                    |m: &LoginRequest| { &m.file_descriptor },
                    |m: &mut LoginRequest| { &mut m.file_descriptor },
                ));
                fields.push(::protobuf::reflect::accessor::make_repeated_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<Record>>(
                    "records",
                    |m: &LoginRequest| { &m.records },
                    |m: &mut LoginRequest| { &mut m.records },
                ));
                ::protobuf::reflect::MessageDescriptor::new::<LoginRequest>(
                    "LoginRequest",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }

    fn default_instance() -> &'static LoginRequest {
        static mut instance: ::protobuf::lazy::Lazy<LoginRequest> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const LoginRequest,
        };
        unsafe {
            instance.get(LoginRequest::new)
        }
    }
}

impl ::protobuf::Clear for LoginRequest {
    fn clear(&mut self) {
        self.username.clear();
        self.password.clear();
        self.keyspace.clear();
        self.file_descriptor.clear();
        self.records.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for LoginRequest {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for LoginRequest {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct Record {
    // message fields
    pub field_options: ::std::collections::HashMap<::std::string::String, FieldOptions>,
    pub name: ::std::string::String,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a Record {
    fn default() -> &'a Record {
        <Record as ::protobuf::Message>::default_instance()
    }
}

impl Record {
    pub fn new() -> Record {
        ::std::default::Default::default()
    }

    // repeated .vinyl.Record.FieldOptionsEntry field_options = 1;


    pub fn get_field_options(&self) -> &::std::collections::HashMap<::std::string::String, FieldOptions> {
        &self.field_options
    }
    pub fn clear_field_options(&mut self) {
        self.field_options.clear();
    }

    // Param is passed by value, moved
    pub fn set_field_options(&mut self, v: ::std::collections::HashMap<::std::string::String, FieldOptions>) {
        self.field_options = v;
    }

    // Mutable pointer to the field.
    pub fn mut_field_options(&mut self) -> &mut ::std::collections::HashMap<::std::string::String, FieldOptions> {
        &mut self.field_options
    }

    // Take field
    pub fn take_field_options(&mut self) -> ::std::collections::HashMap<::std::string::String, FieldOptions> {
        ::std::mem::replace(&mut self.field_options, ::std::collections::HashMap::new())
    }

    // string name = 2;


    pub fn get_name(&self) -> &str {
        &self.name
    }
    pub fn clear_name(&mut self) {
        self.name.clear();
    }

    // Param is passed by value, moved
    pub fn set_name(&mut self, v: ::std::string::String) {
        self.name = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_name(&mut self) -> &mut ::std::string::String {
        &mut self.name
    }

    // Take field
    pub fn take_name(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.name, ::std::string::String::new())
    }
}

impl ::protobuf::Message for Record {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_map_into::<::protobuf::types::ProtobufTypeString, ::protobuf::types::ProtobufTypeMessage<FieldOptions>>(wire_type, is, &mut self.field_options)?;
                },
                2 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.name)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        my_size += ::protobuf::rt::compute_map_size::<::protobuf::types::ProtobufTypeString, ::protobuf::types::ProtobufTypeMessage<FieldOptions>>(1, &self.field_options);
        if !self.name.is_empty() {
            my_size += ::protobuf::rt::string_size(2, &self.name);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        ::protobuf::rt::write_map_with_cached_sizes::<::protobuf::types::ProtobufTypeString, ::protobuf::types::ProtobufTypeMessage<FieldOptions>>(1, &self.field_options, os)?;
        if !self.name.is_empty() {
            os.write_string(2, &self.name)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> Record {
        Record::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_map_accessor::<_, ::protobuf::types::ProtobufTypeString, ::protobuf::types::ProtobufTypeMessage<FieldOptions>>(
                    "field_options",
                    |m: &Record| { &m.field_options },
                    |m: &mut Record| { &mut m.field_options },
                ));
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                    "name",
                    |m: &Record| { &m.name },
                    |m: &mut Record| { &mut m.name },
                ));
                ::protobuf::reflect::MessageDescriptor::new::<Record>(
                    "Record",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }

    fn default_instance() -> &'static Record {
        static mut instance: ::protobuf::lazy::Lazy<Record> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const Record,
        };
        unsafe {
            instance.get(Record::new)
        }
    }
}

impl ::protobuf::Clear for Record {
    fn clear(&mut self) {
        self.field_options.clear();
        self.name.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for Record {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for Record {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct FieldOptions {
    // message fields
    pub primary_key: bool,
    pub index: ::protobuf::SingularPtrField<FieldOptions_IndexOption>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a FieldOptions {
    fn default() -> &'a FieldOptions {
        <FieldOptions as ::protobuf::Message>::default_instance()
    }
}

impl FieldOptions {
    pub fn new() -> FieldOptions {
        ::std::default::Default::default()
    }

    // bool primary_key = 2;


    pub fn get_primary_key(&self) -> bool {
        self.primary_key
    }
    pub fn clear_primary_key(&mut self) {
        self.primary_key = false;
    }

    // Param is passed by value, moved
    pub fn set_primary_key(&mut self, v: bool) {
        self.primary_key = v;
    }

    // .vinyl.FieldOptions.IndexOption index = 3;


    pub fn get_index(&self) -> &FieldOptions_IndexOption {
        self.index.as_ref().unwrap_or_else(|| FieldOptions_IndexOption::default_instance())
    }
    pub fn clear_index(&mut self) {
        self.index.clear();
    }

    pub fn has_index(&self) -> bool {
        self.index.is_some()
    }

    // Param is passed by value, moved
    pub fn set_index(&mut self, v: FieldOptions_IndexOption) {
        self.index = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_index(&mut self) -> &mut FieldOptions_IndexOption {
        if self.index.is_none() {
            self.index.set_default();
        }
        self.index.as_mut().unwrap()
    }

    // Take field
    pub fn take_index(&mut self) -> FieldOptions_IndexOption {
        self.index.take().unwrap_or_else(|| FieldOptions_IndexOption::new())
    }
}

impl ::protobuf::Message for FieldOptions {
    fn is_initialized(&self) -> bool {
        for v in &self.index {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                2 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_bool()?;
                    self.primary_key = tmp;
                },
                3 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.index)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if self.primary_key != false {
            my_size += 2;
        }
        if let Some(ref v) = self.index.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if self.primary_key != false {
            os.write_bool(2, self.primary_key)?;
        }
        if let Some(ref v) = self.index.as_ref() {
            os.write_tag(3, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> FieldOptions {
        FieldOptions::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeBool>(
                    "primary_key",
                    |m: &FieldOptions| { &m.primary_key },
                    |m: &mut FieldOptions| { &mut m.primary_key },
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<FieldOptions_IndexOption>>(
                    "index",
                    |m: &FieldOptions| { &m.index },
                    |m: &mut FieldOptions| { &mut m.index },
                ));
                ::protobuf::reflect::MessageDescriptor::new::<FieldOptions>(
                    "FieldOptions",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }

    fn default_instance() -> &'static FieldOptions {
        static mut instance: ::protobuf::lazy::Lazy<FieldOptions> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const FieldOptions,
        };
        unsafe {
            instance.get(FieldOptions::new)
        }
    }
}

impl ::protobuf::Clear for FieldOptions {
    fn clear(&mut self) {
        self.primary_key = false;
        self.index.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for FieldOptions {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for FieldOptions {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct FieldOptions_IndexOption {
    // message fields
    pub field_type: ::std::string::String,
    pub unique: bool,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a FieldOptions_IndexOption {
    fn default() -> &'a FieldOptions_IndexOption {
        <FieldOptions_IndexOption as ::protobuf::Message>::default_instance()
    }
}

impl FieldOptions_IndexOption {
    pub fn new() -> FieldOptions_IndexOption {
        ::std::default::Default::default()
    }

    // string type = 1;


    pub fn get_field_type(&self) -> &str {
        &self.field_type
    }
    pub fn clear_field_type(&mut self) {
        self.field_type.clear();
    }

    // Param is passed by value, moved
    pub fn set_field_type(&mut self, v: ::std::string::String) {
        self.field_type = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_field_type(&mut self) -> &mut ::std::string::String {
        &mut self.field_type
    }

    // Take field
    pub fn take_field_type(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.field_type, ::std::string::String::new())
    }

    // bool unique = 2;


    pub fn get_unique(&self) -> bool {
        self.unique
    }
    pub fn clear_unique(&mut self) {
        self.unique = false;
    }

    // Param is passed by value, moved
    pub fn set_unique(&mut self, v: bool) {
        self.unique = v;
    }
}

impl ::protobuf::Message for FieldOptions_IndexOption {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.field_type)?;
                },
                2 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_bool()?;
                    self.unique = tmp;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if !self.field_type.is_empty() {
            my_size += ::protobuf::rt::string_size(1, &self.field_type);
        }
        if self.unique != false {
            my_size += 2;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if !self.field_type.is_empty() {
            os.write_string(1, &self.field_type)?;
        }
        if self.unique != false {
            os.write_bool(2, self.unique)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> FieldOptions_IndexOption {
        FieldOptions_IndexOption::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                    "type",
                    |m: &FieldOptions_IndexOption| { &m.field_type },
                    |m: &mut FieldOptions_IndexOption| { &mut m.field_type },
                ));
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeBool>(
                    "unique",
                    |m: &FieldOptions_IndexOption| { &m.unique },
                    |m: &mut FieldOptions_IndexOption| { &mut m.unique },
                ));
                ::protobuf::reflect::MessageDescriptor::new::<FieldOptions_IndexOption>(
                    "FieldOptions_IndexOption",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }

    fn default_instance() -> &'static FieldOptions_IndexOption {
        static mut instance: ::protobuf::lazy::Lazy<FieldOptions_IndexOption> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const FieldOptions_IndexOption,
        };
        unsafe {
            instance.get(FieldOptions_IndexOption::new)
        }
    }
}

impl ::protobuf::Clear for FieldOptions_IndexOption {
    fn clear(&mut self) {
        self.field_type.clear();
        self.unique = false;
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for FieldOptions_IndexOption {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for FieldOptions_IndexOption {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct LoginResponse {
    // message fields
    pub token: ::std::string::String,
    pub error: ::std::string::String,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a LoginResponse {
    fn default() -> &'a LoginResponse {
        <LoginResponse as ::protobuf::Message>::default_instance()
    }
}

impl LoginResponse {
    pub fn new() -> LoginResponse {
        ::std::default::Default::default()
    }

    // string token = 1;


    pub fn get_token(&self) -> &str {
        &self.token
    }
    pub fn clear_token(&mut self) {
        self.token.clear();
    }

    // Param is passed by value, moved
    pub fn set_token(&mut self, v: ::std::string::String) {
        self.token = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_token(&mut self) -> &mut ::std::string::String {
        &mut self.token
    }

    // Take field
    pub fn take_token(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.token, ::std::string::String::new())
    }

    // string error = 2;


    pub fn get_error(&self) -> &str {
        &self.error
    }
    pub fn clear_error(&mut self) {
        self.error.clear();
    }

    // Param is passed by value, moved
    pub fn set_error(&mut self, v: ::std::string::String) {
        self.error = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_error(&mut self) -> &mut ::std::string::String {
        &mut self.error
    }

    // Take field
    pub fn take_error(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.error, ::std::string::String::new())
    }
}

impl ::protobuf::Message for LoginResponse {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.token)?;
                },
                2 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.error)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if !self.token.is_empty() {
            my_size += ::protobuf::rt::string_size(1, &self.token);
        }
        if !self.error.is_empty() {
            my_size += ::protobuf::rt::string_size(2, &self.error);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if !self.token.is_empty() {
            os.write_string(1, &self.token)?;
        }
        if !self.error.is_empty() {
            os.write_string(2, &self.error)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> LoginResponse {
        LoginResponse::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                    "token",
                    |m: &LoginResponse| { &m.token },
                    |m: &mut LoginResponse| { &mut m.token },
                ));
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                    "error",
                    |m: &LoginResponse| { &m.error },
                    |m: &mut LoginResponse| { &mut m.error },
                ));
                ::protobuf::reflect::MessageDescriptor::new::<LoginResponse>(
                    "LoginResponse",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }

    fn default_instance() -> &'static LoginResponse {
        static mut instance: ::protobuf::lazy::Lazy<LoginResponse> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const LoginResponse,
        };
        unsafe {
            instance.get(LoginResponse::new)
        }
    }
}

impl ::protobuf::Clear for LoginResponse {
    fn clear(&mut self) {
        self.token.clear();
        self.error.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for LoginResponse {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for LoginResponse {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct Query {
    // message fields
    pub record_query: ::protobuf::SingularPtrField<RecordQuery>,
    pub execute_properties: ::protobuf::SingularPtrField<ExecuteProperties>,
    pub primary_key: ::protobuf::SingularPtrField<Value>,
    pub query_type: Query_QueryType,
    pub record_type: ::std::string::String,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a Query {
    fn default() -> &'a Query {
        <Query as ::protobuf::Message>::default_instance()
    }
}

impl Query {
    pub fn new() -> Query {
        ::std::default::Default::default()
    }

    // .vinyl.RecordQuery record_query = 1;


    pub fn get_record_query(&self) -> &RecordQuery {
        self.record_query.as_ref().unwrap_or_else(|| RecordQuery::default_instance())
    }
    pub fn clear_record_query(&mut self) {
        self.record_query.clear();
    }

    pub fn has_record_query(&self) -> bool {
        self.record_query.is_some()
    }

    // Param is passed by value, moved
    pub fn set_record_query(&mut self, v: RecordQuery) {
        self.record_query = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_record_query(&mut self) -> &mut RecordQuery {
        if self.record_query.is_none() {
            self.record_query.set_default();
        }
        self.record_query.as_mut().unwrap()
    }

    // Take field
    pub fn take_record_query(&mut self) -> RecordQuery {
        self.record_query.take().unwrap_or_else(|| RecordQuery::new())
    }

    // .vinyl.ExecuteProperties execute_properties = 4;


    pub fn get_execute_properties(&self) -> &ExecuteProperties {
        self.execute_properties.as_ref().unwrap_or_else(|| ExecuteProperties::default_instance())
    }
    pub fn clear_execute_properties(&mut self) {
        self.execute_properties.clear();
    }

    pub fn has_execute_properties(&self) -> bool {
        self.execute_properties.is_some()
    }

    // Param is passed by value, moved
    pub fn set_execute_properties(&mut self, v: ExecuteProperties) {
        self.execute_properties = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_execute_properties(&mut self) -> &mut ExecuteProperties {
        if self.execute_properties.is_none() {
            self.execute_properties.set_default();
        }
        self.execute_properties.as_mut().unwrap()
    }

    // Take field
    pub fn take_execute_properties(&mut self) -> ExecuteProperties {
        self.execute_properties.take().unwrap_or_else(|| ExecuteProperties::new())
    }

    // .vinyl.Value primary_key = 5;


    pub fn get_primary_key(&self) -> &Value {
        self.primary_key.as_ref().unwrap_or_else(|| Value::default_instance())
    }
    pub fn clear_primary_key(&mut self) {
        self.primary_key.clear();
    }

    pub fn has_primary_key(&self) -> bool {
        self.primary_key.is_some()
    }

    // Param is passed by value, moved
    pub fn set_primary_key(&mut self, v: Value) {
        self.primary_key = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_primary_key(&mut self) -> &mut Value {
        if self.primary_key.is_none() {
            self.primary_key.set_default();
        }
        self.primary_key.as_mut().unwrap()
    }

    // Take field
    pub fn take_primary_key(&mut self) -> Value {
        self.primary_key.take().unwrap_or_else(|| Value::new())
    }

    // .vinyl.Query.QueryType query_type = 3;


    pub fn get_query_type(&self) -> Query_QueryType {
        self.query_type
    }
    pub fn clear_query_type(&mut self) {
        self.query_type = Query_QueryType::RECORD_QUERY;
    }

    // Param is passed by value, moved
    pub fn set_query_type(&mut self, v: Query_QueryType) {
        self.query_type = v;
    }

    // string record_type = 6;


    pub fn get_record_type(&self) -> &str {
        &self.record_type
    }
    pub fn clear_record_type(&mut self) {
        self.record_type.clear();
    }

    // Param is passed by value, moved
    pub fn set_record_type(&mut self, v: ::std::string::String) {
        self.record_type = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_record_type(&mut self) -> &mut ::std::string::String {
        &mut self.record_type
    }

    // Take field
    pub fn take_record_type(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.record_type, ::std::string::String::new())
    }
}

impl ::protobuf::Message for Query {
    fn is_initialized(&self) -> bool {
        for v in &self.record_query {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.execute_properties {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.primary_key {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.record_query)?;
                },
                4 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.execute_properties)?;
                },
                5 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.primary_key)?;
                },
                3 => {
                    ::protobuf::rt::read_proto3_enum_with_unknown_fields_into(wire_type, is, &mut self.query_type, 3, &mut self.unknown_fields)?
                },
                6 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.record_type)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(ref v) = self.record_query.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if let Some(ref v) = self.execute_properties.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if let Some(ref v) = self.primary_key.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if self.query_type != Query_QueryType::RECORD_QUERY {
            my_size += ::protobuf::rt::enum_size(3, self.query_type);
        }
        if !self.record_type.is_empty() {
            my_size += ::protobuf::rt::string_size(6, &self.record_type);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(ref v) = self.record_query.as_ref() {
            os.write_tag(1, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        if let Some(ref v) = self.execute_properties.as_ref() {
            os.write_tag(4, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        if let Some(ref v) = self.primary_key.as_ref() {
            os.write_tag(5, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        if self.query_type != Query_QueryType::RECORD_QUERY {
            os.write_enum(3, self.query_type.value())?;
        }
        if !self.record_type.is_empty() {
            os.write_string(6, &self.record_type)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> Query {
        Query::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<RecordQuery>>(
                    "record_query",
                    |m: &Query| { &m.record_query },
                    |m: &mut Query| { &mut m.record_query },
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<ExecuteProperties>>(
                    "execute_properties",
                    |m: &Query| { &m.execute_properties },
                    |m: &mut Query| { &mut m.execute_properties },
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<Value>>(
                    "primary_key",
                    |m: &Query| { &m.primary_key },
                    |m: &mut Query| { &mut m.primary_key },
                ));
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeEnum<Query_QueryType>>(
                    "query_type",
                    |m: &Query| { &m.query_type },
                    |m: &mut Query| { &mut m.query_type },
                ));
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                    "record_type",
                    |m: &Query| { &m.record_type },
                    |m: &mut Query| { &mut m.record_type },
                ));
                ::protobuf::reflect::MessageDescriptor::new::<Query>(
                    "Query",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }

    fn default_instance() -> &'static Query {
        static mut instance: ::protobuf::lazy::Lazy<Query> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const Query,
        };
        unsafe {
            instance.get(Query::new)
        }
    }
}

impl ::protobuf::Clear for Query {
    fn clear(&mut self) {
        self.record_query.clear();
        self.execute_properties.clear();
        self.primary_key.clear();
        self.query_type = Query_QueryType::RECORD_QUERY;
        self.record_type.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for Query {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for Query {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(Clone,PartialEq,Eq,Debug,Hash)]
pub enum Query_QueryType {
    RECORD_QUERY = 0,
    DELETE_WHERE = 1,
    DELETE_RECORD = 2,
    LOAD_RECORD = 3,
}

impl ::protobuf::ProtobufEnum for Query_QueryType {
    fn value(&self) -> i32 {
        *self as i32
    }

    fn from_i32(value: i32) -> ::std::option::Option<Query_QueryType> {
        match value {
            0 => ::std::option::Option::Some(Query_QueryType::RECORD_QUERY),
            1 => ::std::option::Option::Some(Query_QueryType::DELETE_WHERE),
            2 => ::std::option::Option::Some(Query_QueryType::DELETE_RECORD),
            3 => ::std::option::Option::Some(Query_QueryType::LOAD_RECORD),
            _ => ::std::option::Option::None
        }
    }

    fn values() -> &'static [Self] {
        static values: &'static [Query_QueryType] = &[
            Query_QueryType::RECORD_QUERY,
            Query_QueryType::DELETE_WHERE,
            Query_QueryType::DELETE_RECORD,
            Query_QueryType::LOAD_RECORD,
        ];
        values
    }

    fn enum_descriptor_static() -> &'static ::protobuf::reflect::EnumDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::EnumDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::EnumDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                ::protobuf::reflect::EnumDescriptor::new("Query_QueryType", file_descriptor_proto())
            })
        }
    }
}

impl ::std::marker::Copy for Query_QueryType {
}

impl ::std::default::Default for Query_QueryType {
    fn default() -> Self {
        Query_QueryType::RECORD_QUERY
    }
}

impl ::protobuf::reflect::ProtobufValue for Query_QueryType {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Enum(self.descriptor())
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct RecordQuery {
    // message fields
    pub filter: ::protobuf::SingularPtrField<QueryComponent>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a RecordQuery {
    fn default() -> &'a RecordQuery {
        <RecordQuery as ::protobuf::Message>::default_instance()
    }
}

impl RecordQuery {
    pub fn new() -> RecordQuery {
        ::std::default::Default::default()
    }

    // .vinyl.QueryComponent filter = 1;


    pub fn get_filter(&self) -> &QueryComponent {
        self.filter.as_ref().unwrap_or_else(|| QueryComponent::default_instance())
    }
    pub fn clear_filter(&mut self) {
        self.filter.clear();
    }

    pub fn has_filter(&self) -> bool {
        self.filter.is_some()
    }

    // Param is passed by value, moved
    pub fn set_filter(&mut self, v: QueryComponent) {
        self.filter = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_filter(&mut self) -> &mut QueryComponent {
        if self.filter.is_none() {
            self.filter.set_default();
        }
        self.filter.as_mut().unwrap()
    }

    // Take field
    pub fn take_filter(&mut self) -> QueryComponent {
        self.filter.take().unwrap_or_else(|| QueryComponent::new())
    }
}

impl ::protobuf::Message for RecordQuery {
    fn is_initialized(&self) -> bool {
        for v in &self.filter {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.filter)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(ref v) = self.filter.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(ref v) = self.filter.as_ref() {
            os.write_tag(1, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> RecordQuery {
        RecordQuery::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<QueryComponent>>(
                    "filter",
                    |m: &RecordQuery| { &m.filter },
                    |m: &mut RecordQuery| { &mut m.filter },
                ));
                ::protobuf::reflect::MessageDescriptor::new::<RecordQuery>(
                    "RecordQuery",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }

    fn default_instance() -> &'static RecordQuery {
        static mut instance: ::protobuf::lazy::Lazy<RecordQuery> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const RecordQuery,
        };
        unsafe {
            instance.get(RecordQuery::new)
        }
    }
}

impl ::protobuf::Clear for RecordQuery {
    fn clear(&mut self) {
        self.filter.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for RecordQuery {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for RecordQuery {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct ExecuteProperties {
    // message fields
    pub limit: i32,
    pub skip: i32,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a ExecuteProperties {
    fn default() -> &'a ExecuteProperties {
        <ExecuteProperties as ::protobuf::Message>::default_instance()
    }
}

impl ExecuteProperties {
    pub fn new() -> ExecuteProperties {
        ::std::default::Default::default()
    }

    // int32 limit = 1;


    pub fn get_limit(&self) -> i32 {
        self.limit
    }
    pub fn clear_limit(&mut self) {
        self.limit = 0;
    }

    // Param is passed by value, moved
    pub fn set_limit(&mut self, v: i32) {
        self.limit = v;
    }

    // int32 skip = 2;


    pub fn get_skip(&self) -> i32 {
        self.skip
    }
    pub fn clear_skip(&mut self) {
        self.skip = 0;
    }

    // Param is passed by value, moved
    pub fn set_skip(&mut self, v: i32) {
        self.skip = v;
    }
}

impl ::protobuf::Message for ExecuteProperties {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_int32()?;
                    self.limit = tmp;
                },
                2 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_int32()?;
                    self.skip = tmp;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if self.limit != 0 {
            my_size += ::protobuf::rt::value_size(1, self.limit, ::protobuf::wire_format::WireTypeVarint);
        }
        if self.skip != 0 {
            my_size += ::protobuf::rt::value_size(2, self.skip, ::protobuf::wire_format::WireTypeVarint);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if self.limit != 0 {
            os.write_int32(1, self.limit)?;
        }
        if self.skip != 0 {
            os.write_int32(2, self.skip)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> ExecuteProperties {
        ExecuteProperties::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeInt32>(
                    "limit",
                    |m: &ExecuteProperties| { &m.limit },
                    |m: &mut ExecuteProperties| { &mut m.limit },
                ));
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeInt32>(
                    "skip",
                    |m: &ExecuteProperties| { &m.skip },
                    |m: &mut ExecuteProperties| { &mut m.skip },
                ));
                ::protobuf::reflect::MessageDescriptor::new::<ExecuteProperties>(
                    "ExecuteProperties",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }

    fn default_instance() -> &'static ExecuteProperties {
        static mut instance: ::protobuf::lazy::Lazy<ExecuteProperties> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ExecuteProperties,
        };
        unsafe {
            instance.get(ExecuteProperties::new)
        }
    }
}

impl ::protobuf::Clear for ExecuteProperties {
    fn clear(&mut self) {
        self.limit = 0;
        self.skip = 0;
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for ExecuteProperties {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for ExecuteProperties {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct QueryComponent {
    // message fields
    pub child: ::protobuf::SingularPtrField<QueryComponent>,
    pub children: ::protobuf::RepeatedField<QueryComponent>,
    pub component_type: QueryComponent_ComponentType,
    pub field: ::protobuf::SingularPtrField<Field>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a QueryComponent {
    fn default() -> &'a QueryComponent {
        <QueryComponent as ::protobuf::Message>::default_instance()
    }
}

impl QueryComponent {
    pub fn new() -> QueryComponent {
        ::std::default::Default::default()
    }

    // .vinyl.QueryComponent child = 1;


    pub fn get_child(&self) -> &QueryComponent {
        self.child.as_ref().unwrap_or_else(|| QueryComponent::default_instance())
    }
    pub fn clear_child(&mut self) {
        self.child.clear();
    }

    pub fn has_child(&self) -> bool {
        self.child.is_some()
    }

    // Param is passed by value, moved
    pub fn set_child(&mut self, v: QueryComponent) {
        self.child = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_child(&mut self) -> &mut QueryComponent {
        if self.child.is_none() {
            self.child.set_default();
        }
        self.child.as_mut().unwrap()
    }

    // Take field
    pub fn take_child(&mut self) -> QueryComponent {
        self.child.take().unwrap_or_else(|| QueryComponent::new())
    }

    // repeated .vinyl.QueryComponent children = 2;


    pub fn get_children(&self) -> &[QueryComponent] {
        &self.children
    }
    pub fn clear_children(&mut self) {
        self.children.clear();
    }

    // Param is passed by value, moved
    pub fn set_children(&mut self, v: ::protobuf::RepeatedField<QueryComponent>) {
        self.children = v;
    }

    // Mutable pointer to the field.
    pub fn mut_children(&mut self) -> &mut ::protobuf::RepeatedField<QueryComponent> {
        &mut self.children
    }

    // Take field
    pub fn take_children(&mut self) -> ::protobuf::RepeatedField<QueryComponent> {
        ::std::mem::replace(&mut self.children, ::protobuf::RepeatedField::new())
    }

    // .vinyl.QueryComponent.ComponentType component_type = 3;


    pub fn get_component_type(&self) -> QueryComponent_ComponentType {
        self.component_type
    }
    pub fn clear_component_type(&mut self) {
        self.component_type = QueryComponent_ComponentType::AND;
    }

    // Param is passed by value, moved
    pub fn set_component_type(&mut self, v: QueryComponent_ComponentType) {
        self.component_type = v;
    }

    // .vinyl.Field field = 4;


    pub fn get_field(&self) -> &Field {
        self.field.as_ref().unwrap_or_else(|| Field::default_instance())
    }
    pub fn clear_field(&mut self) {
        self.field.clear();
    }

    pub fn has_field(&self) -> bool {
        self.field.is_some()
    }

    // Param is passed by value, moved
    pub fn set_field(&mut self, v: Field) {
        self.field = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_field(&mut self) -> &mut Field {
        if self.field.is_none() {
            self.field.set_default();
        }
        self.field.as_mut().unwrap()
    }

    // Take field
    pub fn take_field(&mut self) -> Field {
        self.field.take().unwrap_or_else(|| Field::new())
    }
}

impl ::protobuf::Message for QueryComponent {
    fn is_initialized(&self) -> bool {
        for v in &self.child {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.children {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.field {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.child)?;
                },
                2 => {
                    ::protobuf::rt::read_repeated_message_into(wire_type, is, &mut self.children)?;
                },
                3 => {
                    ::protobuf::rt::read_proto3_enum_with_unknown_fields_into(wire_type, is, &mut self.component_type, 3, &mut self.unknown_fields)?
                },
                4 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.field)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(ref v) = self.child.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        for value in &self.children {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        };
        if self.component_type != QueryComponent_ComponentType::AND {
            my_size += ::protobuf::rt::enum_size(3, self.component_type);
        }
        if let Some(ref v) = self.field.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(ref v) = self.child.as_ref() {
            os.write_tag(1, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        for v in &self.children {
            os.write_tag(2, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        };
        if self.component_type != QueryComponent_ComponentType::AND {
            os.write_enum(3, self.component_type.value())?;
        }
        if let Some(ref v) = self.field.as_ref() {
            os.write_tag(4, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> QueryComponent {
        QueryComponent::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<QueryComponent>>(
                    "child",
                    |m: &QueryComponent| { &m.child },
                    |m: &mut QueryComponent| { &mut m.child },
                ));
                fields.push(::protobuf::reflect::accessor::make_repeated_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<QueryComponent>>(
                    "children",
                    |m: &QueryComponent| { &m.children },
                    |m: &mut QueryComponent| { &mut m.children },
                ));
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeEnum<QueryComponent_ComponentType>>(
                    "component_type",
                    |m: &QueryComponent| { &m.component_type },
                    |m: &mut QueryComponent| { &mut m.component_type },
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<Field>>(
                    "field",
                    |m: &QueryComponent| { &m.field },
                    |m: &mut QueryComponent| { &mut m.field },
                ));
                ::protobuf::reflect::MessageDescriptor::new::<QueryComponent>(
                    "QueryComponent",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }

    fn default_instance() -> &'static QueryComponent {
        static mut instance: ::protobuf::lazy::Lazy<QueryComponent> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const QueryComponent,
        };
        unsafe {
            instance.get(QueryComponent::new)
        }
    }
}

impl ::protobuf::Clear for QueryComponent {
    fn clear(&mut self) {
        self.child.clear();
        self.children.clear();
        self.component_type = QueryComponent_ComponentType::AND;
        self.field.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for QueryComponent {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for QueryComponent {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(Clone,PartialEq,Eq,Debug,Hash)]
pub enum QueryComponent_ComponentType {
    AND = 0,
    OR = 1,
    NOT = 2,
    FIELD = 3,
}

impl ::protobuf::ProtobufEnum for QueryComponent_ComponentType {
    fn value(&self) -> i32 {
        *self as i32
    }

    fn from_i32(value: i32) -> ::std::option::Option<QueryComponent_ComponentType> {
        match value {
            0 => ::std::option::Option::Some(QueryComponent_ComponentType::AND),
            1 => ::std::option::Option::Some(QueryComponent_ComponentType::OR),
            2 => ::std::option::Option::Some(QueryComponent_ComponentType::NOT),
            3 => ::std::option::Option::Some(QueryComponent_ComponentType::FIELD),
            _ => ::std::option::Option::None
        }
    }

    fn values() -> &'static [Self] {
        static values: &'static [QueryComponent_ComponentType] = &[
            QueryComponent_ComponentType::AND,
            QueryComponent_ComponentType::OR,
            QueryComponent_ComponentType::NOT,
            QueryComponent_ComponentType::FIELD,
        ];
        values
    }

    fn enum_descriptor_static() -> &'static ::protobuf::reflect::EnumDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::EnumDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::EnumDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                ::protobuf::reflect::EnumDescriptor::new("QueryComponent_ComponentType", file_descriptor_proto())
            })
        }
    }
}

impl ::std::marker::Copy for QueryComponent_ComponentType {
}

impl ::std::default::Default for QueryComponent_ComponentType {
    fn default() -> Self {
        QueryComponent_ComponentType::AND
    }
}

impl ::protobuf::reflect::ProtobufValue for QueryComponent_ComponentType {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Enum(self.descriptor())
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct Field {
    // message fields
    pub name: ::std::string::String,
    pub value: ::protobuf::SingularPtrField<Value>,
    pub component_type: Field_ComponentType,
    pub matches: ::protobuf::SingularPtrField<QueryComponent>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a Field {
    fn default() -> &'a Field {
        <Field as ::protobuf::Message>::default_instance()
    }
}

impl Field {
    pub fn new() -> Field {
        ::std::default::Default::default()
    }

    // string name = 1;


    pub fn get_name(&self) -> &str {
        &self.name
    }
    pub fn clear_name(&mut self) {
        self.name.clear();
    }

    // Param is passed by value, moved
    pub fn set_name(&mut self, v: ::std::string::String) {
        self.name = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_name(&mut self) -> &mut ::std::string::String {
        &mut self.name
    }

    // Take field
    pub fn take_name(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.name, ::std::string::String::new())
    }

    // .vinyl.Value value = 2;


    pub fn get_value(&self) -> &Value {
        self.value.as_ref().unwrap_or_else(|| Value::default_instance())
    }
    pub fn clear_value(&mut self) {
        self.value.clear();
    }

    pub fn has_value(&self) -> bool {
        self.value.is_some()
    }

    // Param is passed by value, moved
    pub fn set_value(&mut self, v: Value) {
        self.value = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_value(&mut self) -> &mut Value {
        if self.value.is_none() {
            self.value.set_default();
        }
        self.value.as_mut().unwrap()
    }

    // Take field
    pub fn take_value(&mut self) -> Value {
        self.value.take().unwrap_or_else(|| Value::new())
    }

    // .vinyl.Field.ComponentType component_type = 3;


    pub fn get_component_type(&self) -> Field_ComponentType {
        self.component_type
    }
    pub fn clear_component_type(&mut self) {
        self.component_type = Field_ComponentType::EQUALS;
    }

    // Param is passed by value, moved
    pub fn set_component_type(&mut self, v: Field_ComponentType) {
        self.component_type = v;
    }

    // .vinyl.QueryComponent matches = 4;


    pub fn get_matches(&self) -> &QueryComponent {
        self.matches.as_ref().unwrap_or_else(|| QueryComponent::default_instance())
    }
    pub fn clear_matches(&mut self) {
        self.matches.clear();
    }

    pub fn has_matches(&self) -> bool {
        self.matches.is_some()
    }

    // Param is passed by value, moved
    pub fn set_matches(&mut self, v: QueryComponent) {
        self.matches = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_matches(&mut self) -> &mut QueryComponent {
        if self.matches.is_none() {
            self.matches.set_default();
        }
        self.matches.as_mut().unwrap()
    }

    // Take field
    pub fn take_matches(&mut self) -> QueryComponent {
        self.matches.take().unwrap_or_else(|| QueryComponent::new())
    }
}

impl ::protobuf::Message for Field {
    fn is_initialized(&self) -> bool {
        for v in &self.value {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.matches {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.name)?;
                },
                2 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.value)?;
                },
                3 => {
                    ::protobuf::rt::read_proto3_enum_with_unknown_fields_into(wire_type, is, &mut self.component_type, 3, &mut self.unknown_fields)?
                },
                4 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.matches)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if !self.name.is_empty() {
            my_size += ::protobuf::rt::string_size(1, &self.name);
        }
        if let Some(ref v) = self.value.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if self.component_type != Field_ComponentType::EQUALS {
            my_size += ::protobuf::rt::enum_size(3, self.component_type);
        }
        if let Some(ref v) = self.matches.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if !self.name.is_empty() {
            os.write_string(1, &self.name)?;
        }
        if let Some(ref v) = self.value.as_ref() {
            os.write_tag(2, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        if self.component_type != Field_ComponentType::EQUALS {
            os.write_enum(3, self.component_type.value())?;
        }
        if let Some(ref v) = self.matches.as_ref() {
            os.write_tag(4, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> Field {
        Field::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                    "name",
                    |m: &Field| { &m.name },
                    |m: &mut Field| { &mut m.name },
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<Value>>(
                    "value",
                    |m: &Field| { &m.value },
                    |m: &mut Field| { &mut m.value },
                ));
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeEnum<Field_ComponentType>>(
                    "component_type",
                    |m: &Field| { &m.component_type },
                    |m: &mut Field| { &mut m.component_type },
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<QueryComponent>>(
                    "matches",
                    |m: &Field| { &m.matches },
                    |m: &mut Field| { &mut m.matches },
                ));
                ::protobuf::reflect::MessageDescriptor::new::<Field>(
                    "Field",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }

    fn default_instance() -> &'static Field {
        static mut instance: ::protobuf::lazy::Lazy<Field> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const Field,
        };
        unsafe {
            instance.get(Field::new)
        }
    }
}

impl ::protobuf::Clear for Field {
    fn clear(&mut self) {
        self.name.clear();
        self.value.clear();
        self.component_type = Field_ComponentType::EQUALS;
        self.matches.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for Field {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for Field {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(Clone,PartialEq,Eq,Debug,Hash)]
pub enum Field_ComponentType {
    EQUALS = 0,
    GREATER_THAN = 1,
    LESS_THAN = 2,
    EMPTY = 3,
    NOT_EMPTY = 4,
    IS_NULL = 5,
    MATCHES = 6,
}

impl ::protobuf::ProtobufEnum for Field_ComponentType {
    fn value(&self) -> i32 {
        *self as i32
    }

    fn from_i32(value: i32) -> ::std::option::Option<Field_ComponentType> {
        match value {
            0 => ::std::option::Option::Some(Field_ComponentType::EQUALS),
            1 => ::std::option::Option::Some(Field_ComponentType::GREATER_THAN),
            2 => ::std::option::Option::Some(Field_ComponentType::LESS_THAN),
            3 => ::std::option::Option::Some(Field_ComponentType::EMPTY),
            4 => ::std::option::Option::Some(Field_ComponentType::NOT_EMPTY),
            5 => ::std::option::Option::Some(Field_ComponentType::IS_NULL),
            6 => ::std::option::Option::Some(Field_ComponentType::MATCHES),
            _ => ::std::option::Option::None
        }
    }

    fn values() -> &'static [Self] {
        static values: &'static [Field_ComponentType] = &[
            Field_ComponentType::EQUALS,
            Field_ComponentType::GREATER_THAN,
            Field_ComponentType::LESS_THAN,
            Field_ComponentType::EMPTY,
            Field_ComponentType::NOT_EMPTY,
            Field_ComponentType::IS_NULL,
            Field_ComponentType::MATCHES,
        ];
        values
    }

    fn enum_descriptor_static() -> &'static ::protobuf::reflect::EnumDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::EnumDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::EnumDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                ::protobuf::reflect::EnumDescriptor::new("Field_ComponentType", file_descriptor_proto())
            })
        }
    }
}

impl ::std::marker::Copy for Field_ComponentType {
}

impl ::std::default::Default for Field_ComponentType {
    fn default() -> Self {
        Field_ComponentType::EQUALS
    }
}

impl ::protobuf::reflect::ProtobufValue for Field_ComponentType {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Enum(self.descriptor())
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct Value {
    // message fields
    pub double: f64,
    pub float: f32,
    pub int32: i32,
    pub int64: i64,
    pub sint32: i32,
    pub sint64: i64,
    pub bool: bool,
    pub string: ::std::string::String,
    pub bytes: ::std::vec::Vec<u8>,
    pub value_type: Value_ValueType,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a Value {
    fn default() -> &'a Value {
        <Value as ::protobuf::Message>::default_instance()
    }
}

impl Value {
    pub fn new() -> Value {
        ::std::default::Default::default()
    }

    // double double = 1;


    pub fn get_double(&self) -> f64 {
        self.double
    }
    pub fn clear_double(&mut self) {
        self.double = 0.;
    }

    // Param is passed by value, moved
    pub fn set_double(&mut self, v: f64) {
        self.double = v;
    }

    // float float = 2;


    pub fn get_float(&self) -> f32 {
        self.float
    }
    pub fn clear_float(&mut self) {
        self.float = 0.;
    }

    // Param is passed by value, moved
    pub fn set_float(&mut self, v: f32) {
        self.float = v;
    }

    // int32 int32 = 3;


    pub fn get_int32(&self) -> i32 {
        self.int32
    }
    pub fn clear_int32(&mut self) {
        self.int32 = 0;
    }

    // Param is passed by value, moved
    pub fn set_int32(&mut self, v: i32) {
        self.int32 = v;
    }

    // int64 int64 = 4;


    pub fn get_int64(&self) -> i64 {
        self.int64
    }
    pub fn clear_int64(&mut self) {
        self.int64 = 0;
    }

    // Param is passed by value, moved
    pub fn set_int64(&mut self, v: i64) {
        self.int64 = v;
    }

    // sint32 sint32 = 6;


    pub fn get_sint32(&self) -> i32 {
        self.sint32
    }
    pub fn clear_sint32(&mut self) {
        self.sint32 = 0;
    }

    // Param is passed by value, moved
    pub fn set_sint32(&mut self, v: i32) {
        self.sint32 = v;
    }

    // sint64 sint64 = 7;


    pub fn get_sint64(&self) -> i64 {
        self.sint64
    }
    pub fn clear_sint64(&mut self) {
        self.sint64 = 0;
    }

    // Param is passed by value, moved
    pub fn set_sint64(&mut self, v: i64) {
        self.sint64 = v;
    }

    // bool bool = 10;


    pub fn get_bool(&self) -> bool {
        self.bool
    }
    pub fn clear_bool(&mut self) {
        self.bool = false;
    }

    // Param is passed by value, moved
    pub fn set_bool(&mut self, v: bool) {
        self.bool = v;
    }

    // string string = 11;


    pub fn get_string(&self) -> &str {
        &self.string
    }
    pub fn clear_string(&mut self) {
        self.string.clear();
    }

    // Param is passed by value, moved
    pub fn set_string(&mut self, v: ::std::string::String) {
        self.string = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_string(&mut self) -> &mut ::std::string::String {
        &mut self.string
    }

    // Take field
    pub fn take_string(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.string, ::std::string::String::new())
    }

    // bytes bytes = 12;


    pub fn get_bytes(&self) -> &[u8] {
        &self.bytes
    }
    pub fn clear_bytes(&mut self) {
        self.bytes.clear();
    }

    // Param is passed by value, moved
    pub fn set_bytes(&mut self, v: ::std::vec::Vec<u8>) {
        self.bytes = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_bytes(&mut self) -> &mut ::std::vec::Vec<u8> {
        &mut self.bytes
    }

    // Take field
    pub fn take_bytes(&mut self) -> ::std::vec::Vec<u8> {
        ::std::mem::replace(&mut self.bytes, ::std::vec::Vec::new())
    }

    // .vinyl.Value.ValueType value_type = 20;


    pub fn get_value_type(&self) -> Value_ValueType {
        self.value_type
    }
    pub fn clear_value_type(&mut self) {
        self.value_type = Value_ValueType::DOUBLE;
    }

    // Param is passed by value, moved
    pub fn set_value_type(&mut self, v: Value_ValueType) {
        self.value_type = v;
    }
}

impl ::protobuf::Message for Value {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeFixed64 {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_double()?;
                    self.double = tmp;
                },
                2 => {
                    if wire_type != ::protobuf::wire_format::WireTypeFixed32 {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_float()?;
                    self.float = tmp;
                },
                3 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_int32()?;
                    self.int32 = tmp;
                },
                4 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_int64()?;
                    self.int64 = tmp;
                },
                6 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_sint32()?;
                    self.sint32 = tmp;
                },
                7 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_sint64()?;
                    self.sint64 = tmp;
                },
                10 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_bool()?;
                    self.bool = tmp;
                },
                11 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.string)?;
                },
                12 => {
                    ::protobuf::rt::read_singular_proto3_bytes_into(wire_type, is, &mut self.bytes)?;
                },
                20 => {
                    ::protobuf::rt::read_proto3_enum_with_unknown_fields_into(wire_type, is, &mut self.value_type, 20, &mut self.unknown_fields)?
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if self.double != 0. {
            my_size += 9;
        }
        if self.float != 0. {
            my_size += 5;
        }
        if self.int32 != 0 {
            my_size += ::protobuf::rt::value_size(3, self.int32, ::protobuf::wire_format::WireTypeVarint);
        }
        if self.int64 != 0 {
            my_size += ::protobuf::rt::value_size(4, self.int64, ::protobuf::wire_format::WireTypeVarint);
        }
        if self.sint32 != 0 {
            my_size += ::protobuf::rt::value_varint_zigzag_size(6, self.sint32);
        }
        if self.sint64 != 0 {
            my_size += ::protobuf::rt::value_varint_zigzag_size(7, self.sint64);
        }
        if self.bool != false {
            my_size += 2;
        }
        if !self.string.is_empty() {
            my_size += ::protobuf::rt::string_size(11, &self.string);
        }
        if !self.bytes.is_empty() {
            my_size += ::protobuf::rt::bytes_size(12, &self.bytes);
        }
        if self.value_type != Value_ValueType::DOUBLE {
            my_size += ::protobuf::rt::enum_size(20, self.value_type);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if self.double != 0. {
            os.write_double(1, self.double)?;
        }
        if self.float != 0. {
            os.write_float(2, self.float)?;
        }
        if self.int32 != 0 {
            os.write_int32(3, self.int32)?;
        }
        if self.int64 != 0 {
            os.write_int64(4, self.int64)?;
        }
        if self.sint32 != 0 {
            os.write_sint32(6, self.sint32)?;
        }
        if self.sint64 != 0 {
            os.write_sint64(7, self.sint64)?;
        }
        if self.bool != false {
            os.write_bool(10, self.bool)?;
        }
        if !self.string.is_empty() {
            os.write_string(11, &self.string)?;
        }
        if !self.bytes.is_empty() {
            os.write_bytes(12, &self.bytes)?;
        }
        if self.value_type != Value_ValueType::DOUBLE {
            os.write_enum(20, self.value_type.value())?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> Value {
        Value::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeDouble>(
                    "double",
                    |m: &Value| { &m.double },
                    |m: &mut Value| { &mut m.double },
                ));
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeFloat>(
                    "float",
                    |m: &Value| { &m.float },
                    |m: &mut Value| { &mut m.float },
                ));
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeInt32>(
                    "int32",
                    |m: &Value| { &m.int32 },
                    |m: &mut Value| { &mut m.int32 },
                ));
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeInt64>(
                    "int64",
                    |m: &Value| { &m.int64 },
                    |m: &mut Value| { &mut m.int64 },
                ));
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeSint32>(
                    "sint32",
                    |m: &Value| { &m.sint32 },
                    |m: &mut Value| { &mut m.sint32 },
                ));
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeSint64>(
                    "sint64",
                    |m: &Value| { &m.sint64 },
                    |m: &mut Value| { &mut m.sint64 },
                ));
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeBool>(
                    "bool",
                    |m: &Value| { &m.bool },
                    |m: &mut Value| { &mut m.bool },
                ));
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                    "string",
                    |m: &Value| { &m.string },
                    |m: &mut Value| { &mut m.string },
                ));
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeBytes>(
                    "bytes",
                    |m: &Value| { &m.bytes },
                    |m: &mut Value| { &mut m.bytes },
                ));
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeEnum<Value_ValueType>>(
                    "value_type",
                    |m: &Value| { &m.value_type },
                    |m: &mut Value| { &mut m.value_type },
                ));
                ::protobuf::reflect::MessageDescriptor::new::<Value>(
                    "Value",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }

    fn default_instance() -> &'static Value {
        static mut instance: ::protobuf::lazy::Lazy<Value> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const Value,
        };
        unsafe {
            instance.get(Value::new)
        }
    }
}

impl ::protobuf::Clear for Value {
    fn clear(&mut self) {
        self.double = 0.;
        self.float = 0.;
        self.int32 = 0;
        self.int64 = 0;
        self.sint32 = 0;
        self.sint64 = 0;
        self.bool = false;
        self.string.clear();
        self.bytes.clear();
        self.value_type = Value_ValueType::DOUBLE;
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for Value {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for Value {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(Clone,PartialEq,Eq,Debug,Hash)]
pub enum Value_ValueType {
    DOUBLE = 0,
    FLOAT = 1,
    INT32 = 2,
    INT64 = 3,
    SINT32 = 5,
    SINT64 = 6,
    BOOL = 9,
    STRING = 10,
    BYTES = 11,
}

impl ::protobuf::ProtobufEnum for Value_ValueType {
    fn value(&self) -> i32 {
        *self as i32
    }

    fn from_i32(value: i32) -> ::std::option::Option<Value_ValueType> {
        match value {
            0 => ::std::option::Option::Some(Value_ValueType::DOUBLE),
            1 => ::std::option::Option::Some(Value_ValueType::FLOAT),
            2 => ::std::option::Option::Some(Value_ValueType::INT32),
            3 => ::std::option::Option::Some(Value_ValueType::INT64),
            5 => ::std::option::Option::Some(Value_ValueType::SINT32),
            6 => ::std::option::Option::Some(Value_ValueType::SINT64),
            9 => ::std::option::Option::Some(Value_ValueType::BOOL),
            10 => ::std::option::Option::Some(Value_ValueType::STRING),
            11 => ::std::option::Option::Some(Value_ValueType::BYTES),
            _ => ::std::option::Option::None
        }
    }

    fn values() -> &'static [Self] {
        static values: &'static [Value_ValueType] = &[
            Value_ValueType::DOUBLE,
            Value_ValueType::FLOAT,
            Value_ValueType::INT32,
            Value_ValueType::INT64,
            Value_ValueType::SINT32,
            Value_ValueType::SINT64,
            Value_ValueType::BOOL,
            Value_ValueType::STRING,
            Value_ValueType::BYTES,
        ];
        values
    }

    fn enum_descriptor_static() -> &'static ::protobuf::reflect::EnumDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::EnumDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::EnumDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                ::protobuf::reflect::EnumDescriptor::new("Value_ValueType", file_descriptor_proto())
            })
        }
    }
}

impl ::std::marker::Copy for Value_ValueType {
}

impl ::std::default::Default for Value_ValueType {
    fn default() -> Self {
        Value_ValueType::DOUBLE
    }
}

impl ::protobuf::reflect::ProtobufValue for Value_ValueType {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Enum(self.descriptor())
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct Insert {
    // message fields
    pub record: ::std::string::String,
    pub data: ::std::vec::Vec<u8>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a Insert {
    fn default() -> &'a Insert {
        <Insert as ::protobuf::Message>::default_instance()
    }
}

impl Insert {
    pub fn new() -> Insert {
        ::std::default::Default::default()
    }

    // string record = 1;


    pub fn get_record(&self) -> &str {
        &self.record
    }
    pub fn clear_record(&mut self) {
        self.record.clear();
    }

    // Param is passed by value, moved
    pub fn set_record(&mut self, v: ::std::string::String) {
        self.record = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_record(&mut self) -> &mut ::std::string::String {
        &mut self.record
    }

    // Take field
    pub fn take_record(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.record, ::std::string::String::new())
    }

    // bytes data = 2;


    pub fn get_data(&self) -> &[u8] {
        &self.data
    }
    pub fn clear_data(&mut self) {
        self.data.clear();
    }

    // Param is passed by value, moved
    pub fn set_data(&mut self, v: ::std::vec::Vec<u8>) {
        self.data = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_data(&mut self) -> &mut ::std::vec::Vec<u8> {
        &mut self.data
    }

    // Take field
    pub fn take_data(&mut self) -> ::std::vec::Vec<u8> {
        ::std::mem::replace(&mut self.data, ::std::vec::Vec::new())
    }
}

impl ::protobuf::Message for Insert {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.record)?;
                },
                2 => {
                    ::protobuf::rt::read_singular_proto3_bytes_into(wire_type, is, &mut self.data)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if !self.record.is_empty() {
            my_size += ::protobuf::rt::string_size(1, &self.record);
        }
        if !self.data.is_empty() {
            my_size += ::protobuf::rt::bytes_size(2, &self.data);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if !self.record.is_empty() {
            os.write_string(1, &self.record)?;
        }
        if !self.data.is_empty() {
            os.write_bytes(2, &self.data)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> Insert {
        Insert::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                    "record",
                    |m: &Insert| { &m.record },
                    |m: &mut Insert| { &mut m.record },
                ));
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeBytes>(
                    "data",
                    |m: &Insert| { &m.data },
                    |m: &mut Insert| { &mut m.data },
                ));
                ::protobuf::reflect::MessageDescriptor::new::<Insert>(
                    "Insert",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }

    fn default_instance() -> &'static Insert {
        static mut instance: ::protobuf::lazy::Lazy<Insert> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const Insert,
        };
        unsafe {
            instance.get(Insert::new)
        }
    }
}

impl ::protobuf::Clear for Insert {
    fn clear(&mut self) {
        self.record.clear();
        self.data.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for Insert {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for Insert {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

static file_descriptor_proto_data: &'static [u8] = b"\
    \n\x0ftransport.proto\x12\x05vinyl\"r\n\x07Request\x12\x14\n\x05token\
    \x18\x01\x20\x01(\tR\x05token\x12-\n\ninsertions\x18\x06\x20\x03(\x0b2\r\
    .vinyl.InsertR\ninsertions\x12\"\n\x05query\x18\x07\x20\x01(\x0b2\x0c.vi\
    nyl.QueryR\x05query\":\n\x08Response\x12\x14\n\x05error\x18\x01\x20\x01(\
    \tR\x05error\x12\x18\n\x07records\x18\x02\x20\x03(\x0cR\x07records\"\xb4\
    \x01\n\x0cLoginRequest\x12\x1a\n\x08username\x18\x01\x20\x01(\tR\x08user\
    name\x12\x1a\n\x08password\x18\x02\x20\x01(\tR\x08password\x12\x1a\n\x08\
    keyspace\x18\x03\x20\x01(\tR\x08keyspace\x12'\n\x0ffile_descriptor\x18\
    \x04\x20\x01(\x0cR\x0efileDescriptor\x12'\n\x07records\x18\x05\x20\x03(\
    \x0b2\r.vinyl.RecordR\x07records\"\xb8\x01\n\x06Record\x12D\n\rfield_opt\
    ions\x18\x01\x20\x03(\x0b2\x1f.vinyl.Record.FieldOptionsEntryR\x0cfieldO\
    ptions\x12\x12\n\x04name\x18\x02\x20\x01(\tR\x04name\x1aT\n\x11FieldOpti\
    onsEntry\x12\x10\n\x03key\x18\x01\x20\x01(\tR\x03key\x12)\n\x05value\x18\
    \x02\x20\x01(\x0b2\x13.vinyl.FieldOptionsR\x05value:\x028\x01\"\xa1\x01\
    \n\x0cFieldOptions\x12\x1f\n\x0bprimary_key\x18\x02\x20\x01(\x08R\nprima\
    ryKey\x125\n\x05index\x18\x03\x20\x01(\x0b2\x1f.vinyl.FieldOptions.Index\
    OptionR\x05index\x1a9\n\x0bIndexOption\x12\x12\n\x04type\x18\x01\x20\x01\
    (\tR\x04type\x12\x16\n\x06unique\x18\x02\x20\x01(\x08R\x06unique\";\n\rL\
    oginResponse\x12\x14\n\x05token\x18\x01\x20\x01(\tR\x05token\x12\x14\n\
    \x05error\x18\x02\x20\x01(\tR\x05error\"\xe3\x02\n\x05Query\x125\n\x0cre\
    cord_query\x18\x01\x20\x01(\x0b2\x12.vinyl.RecordQueryR\x0brecordQuery\
    \x12G\n\x12execute_properties\x18\x04\x20\x01(\x0b2\x18.vinyl.ExecutePro\
    pertiesR\x11executeProperties\x12-\n\x0bprimary_key\x18\x05\x20\x01(\x0b\
    2\x0c.vinyl.ValueR\nprimaryKey\x125\n\nquery_type\x18\x03\x20\x01(\x0e2\
    \x16.vinyl.Query.QueryTypeR\tqueryType\x12\x1f\n\x0brecord_type\x18\x06\
    \x20\x01(\tR\nrecordType\"S\n\tQueryType\x12\x10\n\x0cRECORD_QUERY\x10\0\
    \x12\x10\n\x0cDELETE_WHERE\x10\x01\x12\x11\n\rDELETE_RECORD\x10\x02\x12\
    \x0f\n\x0bLOAD_RECORD\x10\x03\"<\n\x0bRecordQuery\x12-\n\x06filter\x18\
    \x01\x20\x01(\x0b2\x15.vinyl.QueryComponentR\x06filter\"=\n\x11ExecutePr\
    operties\x12\x14\n\x05limit\x18\x01\x20\x01(\x05R\x05limit\x12\x12\n\x04\
    skip\x18\x02\x20\x01(\x05R\x04skip\"\x96\x02\n\x0eQueryComponent\x12+\n\
    \x05child\x18\x01\x20\x01(\x0b2\x15.vinyl.QueryComponentR\x05child\x121\
    \n\x08children\x18\x02\x20\x03(\x0b2\x15.vinyl.QueryComponentR\x08childr\
    en\x12J\n\x0ecomponent_type\x18\x03\x20\x01(\x0e2#.vinyl.QueryComponent.\
    ComponentTypeR\rcomponentType\x12\"\n\x05field\x18\x04\x20\x01(\x0b2\x0c\
    .vinyl.FieldR\x05field\"4\n\rComponentType\x12\x07\n\x03AND\x10\0\x12\
    \x06\n\x02OR\x10\x01\x12\x07\n\x03NOT\x10\x02\x12\t\n\x05FIELD\x10\x03\"\
    \xa5\x02\n\x05Field\x12\x12\n\x04name\x18\x01\x20\x01(\tR\x04name\x12\"\
    \n\x05value\x18\x02\x20\x01(\x0b2\x0c.vinyl.ValueR\x05value\x12A\n\x0eco\
    mponent_type\x18\x03\x20\x01(\x0e2\x1a.vinyl.Field.ComponentTypeR\rcompo\
    nentType\x12/\n\x07matches\x18\x04\x20\x01(\x0b2\x15.vinyl.QueryComponen\
    tR\x07matches\"p\n\rComponentType\x12\n\n\x06EQUALS\x10\0\x12\x10\n\x0cG\
    REATER_THAN\x10\x01\x12\r\n\tLESS_THAN\x10\x02\x12\t\n\x05EMPTY\x10\x03\
    \x12\r\n\tNOT_EMPTY\x10\x04\x12\x0b\n\x07IS_NULL\x10\x05\x12\x0b\n\x07MA\
    TCHES\x10\x06\"\xfd\x02\n\x05Value\x12\x16\n\x06double\x18\x01\x20\x01(\
    \x01R\x06double\x12\x14\n\x05float\x18\x02\x20\x01(\x02R\x05float\x12\
    \x14\n\x05int32\x18\x03\x20\x01(\x05R\x05int32\x12\x14\n\x05int64\x18\
    \x04\x20\x01(\x03R\x05int64\x12\x16\n\x06sint32\x18\x06\x20\x01(\x11R\
    \x06sint32\x12\x16\n\x06sint64\x18\x07\x20\x01(\x12R\x06sint64\x12\x12\n\
    \x04bool\x18\n\x20\x01(\x08R\x04bool\x12\x16\n\x06string\x18\x0b\x20\x01\
    (\tR\x06string\x12\x14\n\x05bytes\x18\x0c\x20\x01(\x0cR\x05bytes\x125\n\
    \nvalue_type\x18\x14\x20\x01(\x0e2\x16.vinyl.Value.ValueTypeR\tvalueType\
    \"q\n\tValueType\x12\n\n\x06DOUBLE\x10\0\x12\t\n\x05FLOAT\x10\x01\x12\t\
    \n\x05INT32\x10\x02\x12\t\n\x05INT64\x10\x03\x12\n\n\x06SINT32\x10\x05\
    \x12\n\n\x06SINT64\x10\x06\x12\x08\n\x04BOOL\x10\t\x12\n\n\x06STRING\x10\
    \n\x12\t\n\x05BYTES\x10\x0b\"4\n\x06Insert\x12\x16\n\x06record\x18\x01\
    \x20\x01(\tR\x06record\x12\x12\n\x04data\x18\x02\x20\x01(\x0cR\x04data2i\
    \n\x05Vinyl\x124\n\x05Login\x12\x13.vinyl.LoginRequest\x1a\x14.vinyl.Log\
    inResponse\"\0\x12*\n\x05Query\x12\x0e.vinyl.Request\x1a\x0f.vinyl.Respo\
    nse\"\0B\x12\n\x05vinylZ\ttransportb\x06proto3\
";

static mut file_descriptor_proto_lazy: ::protobuf::lazy::Lazy<::protobuf::descriptor::FileDescriptorProto> = ::protobuf::lazy::Lazy {
    lock: ::protobuf::lazy::ONCE_INIT,
    ptr: 0 as *const ::protobuf::descriptor::FileDescriptorProto,
};

fn parse_descriptor_proto() -> ::protobuf::descriptor::FileDescriptorProto {
    ::protobuf::parse_from_bytes(file_descriptor_proto_data).unwrap()
}

pub fn file_descriptor_proto() -> &'static ::protobuf::descriptor::FileDescriptorProto {
    unsafe {
        file_descriptor_proto_lazy.get(|| {
            parse_descriptor_proto()
        })
    }
}
